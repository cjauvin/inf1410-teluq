# Module 1 — Le génie logiciel

## Qu'est-ce que le GL?

## Histoire du GL

### Les années 40 à mi-60 : l'ère pré-GL
- ENIAC et les premiers ordinateurs
- Premiers assembleurs et compilateurs
- FORTRAN, LISP, ALGO et COBOL
- Premiers OS

### Les années 60 et 70 : la crise logicielle et la naissance du GL
- Conférence NATO (crise du logiciel)
- Programmation structurée
- Modèle en cascade (waterfall)
- Modèle relationnel (base de données)
- Modèle en spirale
- *The Mythical Man-Month*
- Unix et C

### Les années 80 : l'ère des abstractions, du PC et du GUI
- OOP et C++
- GUI et programmation événementielle
- Standardisation de la stack de networking (pré-internet)

### Les années 90 : la naissance du web
- Web
- Open source, Linux
- Design patterns
- Extreme Programming
- UML
- Java

### Les années 00 : l'ère de l'agilité
- Manifeste Agile
- Scrum, Kanban
- AWS
- GitHub

### Les années 10 : l'ère du cloud et du DevOps
- CI/CD
- Microservices
- Docker
- Serverless

### Les années 20 : l'ère de l'IA
- LLM

# Module 2 — La programmation

## Structures de données et algorithmique
- Types de base
- Complexité algorithmique de base

## Principes importants et fameux
- Principe DRY
- KISS
- YAGNI
- Principes SOLID
- Separation of Concerns
- Law of Demeter
- Composition over inheritance
- Boy scout rule
  > “Always leave the campground cleaner than you found it.”
- Principle of Least Astonishment (POLA)
  - Un composant doit se comporter comme on s’y attend
  - Une fonction `calculateTotal()` ne devrait pas aussi envoyer un courriel

## Paradigmes
- Programmation orientée objet (OOP)
- Programmation fonctionnelle

## Design patterns
- Gang of Four

## Principes architecturaux
- Architecture en couches (N-tier)
- Architecture hexagonale
- Microservices vs monolithe
- Serverless

## Web & API
- HTTP
- JSON, REST, GraphQL
- Modèles de sécurité et d’authentification (OAuth, JWT, etc.)

## Testing
- Pourquoi les tests?
- Types de tests et pyramide des tests
- Qualités d’un bon test :
  - rapide
  - déterministe
  - isolé
  - répétable
- Mocking
- Tests de régression, TDD

## Interfaces graphiques (UI)
- Programmation événementielle
- DOM et arbre de vues
- Web vs desktop
- MVC
- Principes d’IHM (HCI)
- UI déclarative vs impérative
- Gestion de l’état
- Notions de *flow* et de *least friction* (bonne UI)

## Programmation parallèle et asynchrone
- Modèles mentaux : CPU-bound vs IO-bound
- Event loop
- Promises et futures
- Async / await
- Threads vs processus
- Problèmes classiques (deadlocks, etc.)

## Documentation
- Documentation du code
- Documentation d’API
- README, changelogs, etc.
- Modèles de données

## Design by contract


# Module 3 — Les outils et les environnements

## Git et le contrôle de versions
- Problème du versioning
- Historique
- Opérations de base
- Branching et merging
- Collaboration distante
- Bonnes pratiques

## IDEs et éditeurs
- IDE vs éditeurs
- Analyse statique, linting
- Navigation dans le code
- Refactoring
- Debugging
- Extensions

## Gestionnaires de paquets
- Dependency hell
- Builds reproductibles
- Artifacts vs sources
- Gestionnaires système vs gestionnaires de langage
- SemVer
- Manifests et lockfiles
- Sécurité et licences

## DevOps
- CI/CD
- Containers
- Infrastructure as Code
- Observabilité et monitoring
- Shift Left

## Assistance par l’IA
- Coding agents
- MCP

# Module 4 — La gestion de projet et la collaboration
- Agile
- Scrum
- Kanban
- DevOps
- Code reviews (GitHub, etc.)
- Tech writing
- Documentation
- Recueil des besoins

# Module 5 — Les données
- SQL
- SQL vs NoSQL
- Intégrité et normalisation
- ORM
- Big data et ML
- Web sémantique
- Caching


# Module 6 — L'infonuagique
- Modèles de service (IaaS, PaaS, SaaS, Serverless)
- Grands fournisseurs (AWS, Azure, GCP)
- Haute disponibilité et scalabilité
