<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Accueil on INF1410 - Initiation au génie logiciel</title><link>https://cjauvin.github.io/inf1410-teluq/</link><description>Recent content in Accueil on INF1410 - Initiation au génie logiciel</description><generator>Hugo</generator><language>fr</language><atom:link href="https://cjauvin.github.io/inf1410-teluq/index.xml" rel="self" type="application/rss+xml"/><item><title>Environnements du cours</title><link>https://cjauvin.github.io/inf1410-teluq/docs/environnements/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/environnements/</guid><description>&lt;h1 id="les-environnements-du-cours"&gt;Les environnements du cours&lt;a class="anchor" href="#les-environnements-du-cours"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;label class="book-image" for="book-image-toggle-0"&gt;
 &lt;input class="hidden toggle" type="checkbox" id="book-image-toggle-0" /&gt;
 &lt;img src="https://cjauvin.github.io/inf1410-teluq/docs/environnements/matrix.jpg" alt=""loading="lazy"title="" /&gt;
&lt;/label&gt;
&lt;script&gt;
(function() {
 const checkbox = document.getElementById('book-image-toggle-0');
 const escapeHandler = function(e) {
 if (e.key === 'Escape' &amp;&amp; checkbox.checked) {
 checkbox.checked = false;
 }
 };
 checkbox.addEventListener('change', function() {
 if (this.checked) {
 document.addEventListener('keydown', escapeHandler);
 } else {
 document.removeEventListener('keydown', escapeHandler);
 }
 });
})();
&lt;/script&gt;
&lt;p&gt;Dans ce cours, nous allons beaucoup utiliser la &lt;a href="https://fr.wikipedia.org/wiki/Interface_en_ligne_de_commande"&gt;ligne de
commande&lt;/a&gt;. La
ligne de commande est un paradigme ancien, qui survit au passage du temps dans
le monde du développement informatique en raison de sa versatilité, de sa
souplesse et de son universalité. La ligne de commande (souvent appelée CLI en
anglais, ou console) est un type d&amp;rsquo;interface usager textuelle (où on manipule du
texte, soit des mots, des commandes, des symboles, des formules, des nombres,
etc) par opposition au type plus moderne de l&amp;rsquo;&lt;a href="https://fr.wikipedia.org/wiki/Interface_graphique"&gt;interface
graphique&lt;/a&gt; (GUI en anglais,
graphical user interface, ou souvent juste UI). Le CLI est plus &amp;ldquo;proche&amp;rdquo; de la
programmation, qui est elle aussi un média essentiellement textuel (et logique,
souvent mathématique).&lt;/p&gt;</description></item><item><title>Le manifeste Agile</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module4/agile/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module4/agile/</guid><description>&lt;h1 id="la-manifeste-agile"&gt;La manifeste Agile&lt;a class="anchor" href="#la-manifeste-agile"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;En quelque au début des années 2000, le mot &amp;ldquo;agile&amp;rdquo; est devenu omniprésent, dans
la culture technologique et même au-delà. Il représente en fait un phénomène
culturel dont la genèse est un petit groupe de professionnels, qui se sont
rassemblés pour mettre en commun leurs idées par rapport au changement de
paradigme dans la culture du développement logiciel, par rapport aux décennies
qui précédaient.&lt;/p&gt;
&lt;p&gt;Voici les douze principes du &lt;a href="https://agilemanifesto.org/iso/fr/principles.html"&gt;manifeste Agile&lt;/a&gt; :&lt;/p&gt;</description></item><item><title>Le versioning avec git</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/versioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module3/versioning/</guid><description>&lt;h1 id="le-versioning"&gt;Le versioning&lt;a class="anchor" href="#le-versioning"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="quel-est-le-problème-quon-cherche-à-résoudre"&gt;Quel est le problème qu&amp;rsquo;on cherche à résoudre?&lt;a class="anchor" href="#quel-est-le-probl%c3%a8me-quon-cherche-%c3%a0-r%c3%a9soudre"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Le logiciel (et le code source dont il est constitué) a une particularité
fondamentale : il change tout le temps. Même un programme simple est rapidement
modifié - pour corriger un bug, ajouter une fonctionnalité, améliorer la
performance ou simplement rendre le code plus lisible. Et très vite, une
question apparaît : comment savoir ce qui a changé, quand, et pourquoi ?&lt;/p&gt;</description></item><item><title>Survol rapide de la programmation</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module2/prog-recap/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module2/prog-recap/</guid><description>&lt;h1 id="survol-rapide-de-la-programmation"&gt;Survol rapide de la programmation&lt;a class="anchor" href="#survol-rapide-de-la-programmation"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Nous allons faire un survol rapide des idées les plus importantes et
fondamentales de la programmation logicielle. Pour aller droit au but, nous
allons utiliser le langage Python, qui est très facile à comprendre, même sans
aucune expérience explicite.&lt;/p&gt;
&lt;h2 id="structures-de-données-fondamentales"&gt;Structures de données fondamentales&lt;a class="anchor" href="#structures-de-donn%c3%a9es-fondamentales"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Au-delà des types de base, qui sont généralement des nombres de différents types
(entiers, réels, etc) et les chaines de caractères (strings), nous avons les
structures de données, qui sont des constructions logiques plus complexe
(non-atomique) qui impliquent, en général, les types de base, d&amp;rsquo;une manière ou
d&amp;rsquo;une autre.&lt;/p&gt;</description></item><item><title>La conteneurisation avec docker</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module3/docker/</guid><description>&lt;h1 id="la-conteneurisation-avec-docker"&gt;La conteneurisation avec docker&lt;a class="anchor" href="#la-conteneurisation-avec-docker"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Cette section propose un chemin rapide et efficace pour comprendre ce qu’est la
technologie Docker, ses concepts de base, et comment utiliser certains de ses
outils principaux. Le but est de favoriser la création d’un modèle mental
robuste, et non de décrire exhaustivement les plus fins détails. Pour ce faire,
nous allons tout d’abord répondre à quelques questions courantes, et explorer
ensuite une série d’exemples, de manière progressive et cohérente.&lt;/p&gt;</description></item><item><title>La gestion des dépendances</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/gestion-des-deps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module3/gestion-des-deps/</guid><description>&lt;h1 id="la-gestion-des-dépendances"&gt;La gestion des dépendances&lt;a class="anchor" href="#la-gestion-des-d%c3%a9pendances"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Dès qu&amp;rsquo;un programme devient un peu plus complexe, deux phénomènes interviennent
habituellement :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Le programme doit être décomposé en plusieurs modules&lt;/li&gt;
&lt;li&gt;Certaines fonctionnalités du programmes, pouvant être accomplies par des
programmes (ou des librairies) externes, doivent être détachées en des
composantes ou des librairies distinctes, qu&amp;rsquo;il est possible de réutiliser
(c&amp;rsquo;est un peu le &lt;a href="https://cjauvin.github.io/inf1410-teluq/docs/module2/principes/#dry-dont-repeat-yourself-ne-vous-r%c3%a9p%c3%a9tez-pas-"&gt;principe
DRY&lt;/a&gt; que
nous avons vu, appliqué dans le sens plus large d&amp;rsquo;un écosystème logiciel)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Dans le cas (2), on nomme parfois les librairies externes des &amp;ldquo;dépendances&amp;rdquo;, ou des
&amp;ldquo;paquets&amp;rdquo; (packages en anglais, plus communément).&lt;/p&gt;</description></item><item><title>Principes généraux fameux</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module2/principes/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module2/principes/</guid><description>&lt;h1 id="quelques-principes-généraux-fameux-en-développement-logiciel"&gt;Quelques principes généraux fameux en développement logiciel&lt;a class="anchor" href="#quelques-principes-g%c3%a9n%c3%a9raux-fameux-en-d%c3%a9veloppement-logiciel"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="dry-dont-repeat-yourself-ne-vous-répétez-pas-"&gt;DRY (Don&amp;rsquo;t Repeat Yourself), ne vous répétez pas !&lt;a class="anchor" href="#dry-dont-repeat-yourself-ne-vous-r%c3%a9p%c3%a9tez-pas-"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Le fameux principe
&lt;a href="https://fr.wikipedia.org/wiki/Ne_vous_r%C3%A9p%C3%A9tez_pas"&gt;DRY&lt;/a&gt; est
assurément l&amp;rsquo;un des plus profonds de l&amp;rsquo;informatique, qui consiste à simplement
reconnaître que c&amp;rsquo;est préférable de modifier quelque chose à un seul endroit,
plutôt que plusieurs, à la fois pour l&amp;rsquo;économie d&amp;rsquo;effort, et la minimisation des
risques d&amp;rsquo;erreur.&lt;/p&gt;
&lt;h2 id="kiss-keep-it-simple-stupid"&gt;KISS: Keep It Simple Stupid&lt;a class="anchor" href="#kiss-keep-it-simple-stupid"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="yagni"&gt;YAGNI&lt;a class="anchor" href="#yagni"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="solid"&gt;SOLID&lt;a class="anchor" href="#solid"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="separation-of-concerns"&gt;Separation of concerns&lt;a class="anchor" href="#separation-of-concerns"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="law-of-demeter"&gt;Law of Demeter&lt;a class="anchor" href="#law-of-demeter"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="composition-over-inheritance"&gt;Composition over inheritance&lt;a class="anchor" href="#composition-over-inheritance"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;h2 id="boy-scout-rule"&gt;Boy scout rule&lt;a class="anchor" href="#boy-scout-rule"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&amp;ldquo;Always leave the campground cleaner than you found it.&amp;rdquo;&lt;/p&gt;</description></item><item><title>Travaux notés</title><link>https://cjauvin.github.io/inf1410-teluq/docs/travaux-not%C3%A9s/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/travaux-not%C3%A9s/</guid><description>&lt;h1 id="les-travaux-notés"&gt;Les travaux notés&lt;a class="anchor" href="#les-travaux-not%c3%a9s"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Étant donné qu&amp;rsquo;il s&amp;rsquo;agit d&amp;rsquo;un cours de génie logiciel, nous avons cherché à
faire en sorte que les travaux soient cohérents et évolutifs. Nous avons donc
choisi un modèle de développement d&amp;rsquo;application qui comportera différents volets
reliés aux grands sujets du cours.&lt;/p&gt;
&lt;p&gt;Nous allons vous demander de développer une application (web) d&amp;rsquo;affaire
commerciale et transactionnelle (possiblement style SaaS).&lt;/p&gt;
&lt;p&gt;Dans un premier temps, il vous faudra imaginer la nature exacte de cette
application, pour ensuite simuler une rencontre du client imaginaire, afin d&amp;rsquo;en
extraire les spécifications et le fonctionnement exacts. Vous devrez ensuite
produire un document de conception, en utilisant une technique de modélisation
de votre choix, afin de tenter de penser d&amp;rsquo;avance au fonctionnement de votre
application, avant de vous lancer dans le développement à proprement parler.&lt;/p&gt;</description></item><item><title>Qu'est-ce que le génie logiciel?</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module1/intro-gl/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module1/intro-gl/</guid><description>&lt;h1 id="quest-ce-que-le-génie-logiciel"&gt;Qu&amp;rsquo;est-ce que le génie logiciel?&lt;a class="anchor" href="#quest-ce-que-le-g%c3%a9nie-logiciel"&gt;#&lt;/a&gt;&lt;/h1&gt;</description></item><item><title>Les idées historiques importantes</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module1/historique/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module1/historique/</guid><description>&lt;h1 id="historique"&gt;Historique&lt;a class="anchor" href="#historique"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="une-conférence-en-temps-de-crise"&gt;Une conférence en temps de crise&lt;a class="anchor" href="#une-conf%c3%a9rence-en-temps-de-crise"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;D&amp;rsquo;une manière similaire à la conférence de Dartmouth qui a dans un sens inauguré
le domaine de l&amp;rsquo;intelligence artificielle en 1956, on peut dire que c&amp;rsquo;est la
conférence NATO, organisée en 1968 en Allemagne, qui a inauguré le génie
logiciel en tant que domaine. Dans cette conférence, il a été question pour la
première fois d&amp;rsquo;une &amp;ldquo;crise du logiciel&amp;rdquo;, qui commençait à se profiler dans
l&amp;rsquo;horizon culturel et technologique de l&amp;rsquo;époque.&lt;/p&gt;</description></item><item><title>Survol historiquee des jalons du GL</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module1/historique2/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module1/historique2/</guid><description>&lt;h1 id="les-jalons-historiques-du-génie-logiciel"&gt;Les jalons historiques du génie logiciel&lt;a class="anchor" href="#les-jalons-historiques-du-g%c3%a9nie-logiciel"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;L&amp;rsquo;histoire du génie logiciel est le récit d&amp;rsquo;une transition : d&amp;rsquo;un &amp;ldquo;artisanat&amp;rdquo; manuel vers une automatisation à l&amp;rsquo;échelle industrielle. Cette évolution a été rythmée par la nécessité constante de dompter une complexité croissante et de répondre aux besoins changeants de la société.&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id="1-lère-des-pionniers-années-1940--1967"&gt;1. L&amp;rsquo;ère des pionniers (Années 1940 – 1967)&lt;a class="anchor" href="#1-l%c3%a8re-des-pionniers-ann%c3%a9es-1940--1967"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Focus : Maîtriser le matériel. La programmation est alors perçue comme une extension de l&amp;rsquo;ingénierie électrique.&lt;/em&gt;&lt;/p&gt;</description></item></channel></rss>