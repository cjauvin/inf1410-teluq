<!doctype html><html lang=fr dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Les jalons historiques du génie logiciel# L’histoire du génie logiciel est le récit d’une transition : d’un “artisanat” manuel vers une automatisation à l’échelle industrielle. Cette évolution a été rythmée par la nécessité constante de dompter une complexité croissante et de répondre aux besoins changeants de la société.
1. L’ère des pionniers (Années 1940 – 1967)# Focus : Maîtriser le matériel. La programmation est alors perçue comme une extension de l’ingénierie électrique.
"><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://cjauvin.github.io/inf1410-teluq/docs/module1/historique2/"><meta property="og:site_name" content="INF1410 - Initiation au génie logiciel"><meta property="og:title" content="Survol historiquee des jalons du GL"><meta property="og:description" content="Les jalons historiques du génie logiciel# L’histoire du génie logiciel est le récit d’une transition : d’un “artisanat” manuel vers une automatisation à l’échelle industrielle. Cette évolution a été rythmée par la nécessité constante de dompter une complexité croissante et de répondre aux besoins changeants de la société.
1. L’ère des pionniers (Années 1940 – 1967)# Focus : Maîtriser le matériel. La programmation est alors perçue comme une extension de l’ingénierie électrique."><meta property="og:locale" content="fr"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta itemprop=name content="Survol historiquee des jalons du GL"><meta itemprop=description content="Les jalons historiques du génie logiciel# L’histoire du génie logiciel est le récit d’une transition : d’un “artisanat” manuel vers une automatisation à l’échelle industrielle. Cette évolution a été rythmée par la nécessité constante de dompter une complexité croissante et de répondre aux besoins changeants de la société.
1. L’ère des pionniers (Années 1940 – 1967)# Focus : Maîtriser le matériel. La programmation est alors perçue comme une extension de l’ingénierie électrique."><meta itemprop=wordCount content="1271"><title>Survol historiquee des jalons du GL | INF1410 - Initiation au génie logiciel</title><link rel=icon href=https://cjauvin.github.io/inf1410-teluq/images/2gears.png><link rel=manifest href=https://cjauvin.github.io/inf1410-teluq/manifest.json><link rel=canonical href=https://cjauvin.github.io/inf1410-teluq/docs/module1/historique2/><link rel=stylesheet href=https://cjauvin.github.io/inf1410-teluq/book.min.165c71395eadf4cc8cb595801cc1691b0169871bbe93de1afb5ecb0f5b7c33ae.css integrity="sha256-FlxxOV6t9MyMtZWAHMFpGwFphxu+k94a+17LD1t8M64=" crossorigin=anonymous><script>MathJax={tex:{inlineMath:[["$","$"],["\\(","\\)"]],displayMath:[["$$","$$"],["\\[","\\]"]],processEscapes:!0,processEnvironments:!0},options:{skipHtmlTags:["script","noscript","style","textarea","pre"]}}</script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=https://cjauvin.github.io/inf1410-teluq/><img src=https://cjauvin.github.io/inf1410-teluq/images/2gears.png alt=Logo><span>INF1410 - Initiation au génie logiciel</span></a></h2><ul><li><input type=checkbox id=section-ceede6672d79ee87ce5f1a12533f0f89 class=toggle checked>
<label for=section-ceede6672d79ee87ce5f1a12533f0f89 class=flex><a href=https://cjauvin.github.io/inf1410-teluq/docs/module1/>Module 1 - Le génie logiciel</a>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=https://cjauvin.github.io/inf1410-teluq/docs/module1/intro-gl/>Qu'est-ce que le génie logiciel?</a></li><li><a href=https://cjauvin.github.io/inf1410-teluq/docs/module1/historique/>Les idées historiques importantes</a></li><li><a href=https://cjauvin.github.io/inf1410-teluq/docs/module1/historique2/ class=active>Survol historiquee des jalons du GL</a></li></ul></li><li><input type=checkbox id=section-6bcde8c955d2ef4a29812289ee291845 class=toggle>
<label for=section-6bcde8c955d2ef4a29812289ee291845 class=flex><a href=https://cjauvin.github.io/inf1410-teluq/docs/module2/>Module 2 - La programmation</a>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><input type=checkbox id=section-dacaf5bf92061137876427d5274f80b8 class=toggle>
<label for=section-dacaf5bf92061137876427d5274f80b8 class=flex><a href=https://cjauvin.github.io/inf1410-teluq/docs/module3/>Module 3 - Les outils et les environnements</a>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/chevron-right.svg class=book-icon alt=Expand></label><ul><li><a href=https://cjauvin.github.io/inf1410-teluq/docs/module3/versioning/>Le versioning avec git</a></li><li><a href=https://cjauvin.github.io/inf1410-teluq/docs/module3/package-managers/>La gestion de packages et de librairies avec uv</a></li></ul></li><li><input type=checkbox id=section-d43313f1368df8488a83030094191c31 class=toggle>
<label for=section-d43313f1368df8488a83030094191c31 class=flex><a href=https://cjauvin.github.io/inf1410-teluq/docs/module4/>Module 4 - La gestion de projet et la collaboration</a>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><input type=checkbox id=section-a26973bae2fed65c6fe8fb0151c28c36 class=toggle>
<label for=section-a26973bae2fed65c6fe8fb0151c28c36 class=flex><a href=https://cjauvin.github.io/inf1410-teluq/docs/module5/>Module 5 - Les données</a>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li><li><input type=checkbox id=section-e048a05c5e3f3e77303c39a90f95ec11 class=toggle>
<label for=section-e048a05c5e3f3e77303c39a90f95ec11 class=flex><a role=button>Module 6 - L'infonuagique</a>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/chevron-right.svg class=book-icon alt=Expand></label><ul></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class="book-header hidden"><div class="flex align-center justify-between"><label for=menu-control><img src=https://cjauvin.github.io/inf1410-teluq/icons/menu.svg class=book-icon alt=Menu></label><h3>Survol historiquee des jalons du GL</h3><label for=toc-control><img src=https://cjauvin.github.io/inf1410-teluq/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class=hidden><nav id=TableOfContents><ul><li><a href=#1-lère-des-pionniers-années-1940--1967>1. L&rsquo;ère des pionniers (Années 1940 – 1967)</a></li><li><a href=#2-la-naissance-du-génie-logiciel-1968--1982>2. La naissance du génie logiciel (1968 – 1982)</a></li><li><a href=#3-maîtriser-la-complexité-et-le-pc-1983--1994>3. Maîtriser la complexité et le PC (1983 – 1994)</a></li><li><a href=#4-la-révolution-agile-et-internet-1995--2009>4. La révolution agile et Internet (1995 – 2009)</a></li><li><a href=#5-lingénierie-continue-et-lia-2010--présent>5. L&rsquo;ingénierie continue et l&rsquo;IA (2010 – présent)</a><ul><li><a href=#tableau-récapitulatif>Tableau récapitulatif</a></li></ul></li></ul></nav></aside></header><article class="markdown book-article"><h1 id=les-jalons-historiques-du-génie-logiciel>Les jalons historiques du génie logiciel<a class=anchor href=#les-jalons-historiques-du-g%c3%a9nie-logiciel>#</a></h1><p>L&rsquo;histoire du génie logiciel est le récit d&rsquo;une transition : d&rsquo;un &ldquo;artisanat&rdquo; manuel vers une automatisation à l&rsquo;échelle industrielle. Cette évolution a été rythmée par la nécessité constante de dompter une complexité croissante et de répondre aux besoins changeants de la société.</p><hr><h2 id=1-lère-des-pionniers-années-1940--1967>1. L&rsquo;ère des pionniers (Années 1940 – 1967)<a class=anchor href=#1-l%c3%a8re-des-pionniers-ann%c3%a9es-1940--1967>#</a></h2><p><em>Focus : Maîtriser le matériel. La programmation est alors perçue comme une extension de l&rsquo;ingénierie électrique.</em></p><ul><li><strong>1952 : Le premier compilateur (Technologie)</strong>
Grace Hopper a développé le <strong>système A-0</strong>, le premier outil capable de traduire des instructions mathématiques en code machine. Avant cela, les programmeurs devaient écrire manuellement en binaire ou en assembleur. Cette invention a ouvert la voie à l&rsquo;abstraction, permettant aux humains de communiquer avec les machines dans un langage plus proche du leur.</li><li><strong>1957 : FORTRAN (Langage)</strong>
Créé par John Backus chez IBM, FORTRAN (Formula Translation) est le premier langage de haut niveau largement adopté. Il a prouvé qu&rsquo;un langage compilé pouvait être aussi efficace que du code écrit à la main, tout en rendant les programmes beaucoup plus lisibles et portables d&rsquo;une machine à une autre.</li><li><strong>1958 : LISP (Tendance/Technologie)</strong>
Inventé par John McCarthy pour la recherche en intelligence artificielle, LISP a introduit des concepts révolutionnaires comme les fonctions récursives, le typage dynamique et le &ldquo;garbage collection&rdquo; (gestion automatique de la mémoire). Il reste l&rsquo;un des langages les plus influents sur la conception des langages modernes.</li><li><strong>1964 : IBM System/360 (Système d&rsquo;exploitation)</strong>
IBM a lancé la première famille d&rsquo;ordinateurs utilisant la même architecture. Pour la première fois, un logiciel écrit pour une petite machine pouvait fonctionner sur une plus grande sans être réécrit. Cela a forcé la création de l&rsquo;OS/360, l&rsquo;un des premiers projets logiciels massifs, illustrant pour la première fois les défis de la gestion d&rsquo;équipes de développement géantes.</li></ul><hr><h2 id=2-la-naissance-du-génie-logiciel-1968--1982>2. La naissance du génie logiciel (1968 – 1982)<a class=anchor href=#2-la-naissance-du-g%c3%a9nie-logiciel-1968--1982>#</a></h2><p><em>Focus : Résoudre la &ldquo;crise du logiciel&rdquo;. Les projets sont systématiquement en retard, hors budget et truffés de bugs.</em></p><ul><li><strong>1968 : La conférence de l&rsquo;OTAN (Méthode)</strong>
Le terme &ldquo;génie logiciel&rdquo; (Software Engineering) est officiellement consacré lors de cette conférence à Garmisch, en Allemagne. L&rsquo;objectif était de transformer la création de logiciels, alors perçue comme un art mystérieux et imprévisible, en une discipline d&rsquo;ingénierie rigoureuse, basée sur des processus théoriques et reproductibles.</li><li><strong>1970 : Le modèle en cascade / Waterfall (Méthode)</strong>
Winston Royce a décrit le premier modèle de processus séquentiel (analyse, conception, codage, tests). Bien que Royce ait lui-même prévenu que ce modèle était risqué sans itérations, il est devenu la norme industrielle pendant des décennies car il offrait une structure rassurante pour la gestion de projet traditionnelle.</li><li><strong>1972 : C et UNIX (Technologie)</strong>
Dennis Ritchie crée le <strong>langage C</strong> et Ken Thompson développe <strong>UNIX</strong>. Ce duo a permis d&rsquo;écrire des systèmes d&rsquo;exploitation performants sans dépendre du langage assembleur spécifique à un processeur. C est devenu le &ldquo;latin&rdquo; de l&rsquo;informatique, servant de fondation à presque tous les systèmes d&rsquo;exploitation et langages modernes.</li><li><strong>1975 : &ldquo;The Mythical Man-Month&rdquo; (Tendance)</strong>
Fred Brooks a publié cet ouvrage fondateur basé sur son expérience chez IBM. Il y formule la <strong>Loi de Brooks</strong> : &ldquo;Ajouter de la main-d&rsquo;œuvre à un projet logiciel en retard ne fait que le retarder davantage&rdquo;. Ce livre a déplacé l&rsquo;attention des problèmes purement techniques vers les problèmes de communication et de structure humaine.</li></ul><hr><h2 id=3-maîtriser-la-complexité-et-le-pc-1983--1994>3. Maîtriser la complexité et le PC (1983 – 1994)<a class=anchor href=#3-ma%c3%aetriser-la-complexit%c3%a9-et-le-pc-1983--1994>#</a></h2><p><em>Focus : Favoriser la réutilisation du code et gérer l&rsquo;explosion de l&rsquo;informatique personnelle.</em></p><ul><li><p><strong>1983 : C++ (Langage)</strong>
Bjarne Stroustrup a ajouté des &ldquo;classes&rdquo; au langage C, popularisant la <strong>programmation orientée objet (POO)</strong>. Cette approche permet de structurer le code en modules réutilisables (objets), ce qui est devenu indispensable pour gérer les interfaces graphiques complexes et les logiciels de bureau des nouveaux PC.</p></li><li><p><strong>1985 : Windows et les interfaces graphiques (Système d&rsquo;exploitation)</strong>
Avec le lancement de Windows 1.0 (puis le succès massif de la version 3.0), Microsoft a généralisé l&rsquo;interface graphique (GUI) sur PC. Pour les ingénieurs, cela a marqué un tournant : il ne s&rsquo;agissait plus de programmer des flux linéaires, mais des systèmes &ldquo;dirigés par les événements&rdquo; (event-driven programming), où le logiciel attend et réagit aux actions de l&rsquo;utilisateur (clics, mouvements de souris).</p></li><li><p><strong>1985 : Le modèle en spirale (Méthode)</strong>
Barry Boehm propose un modèle basé sur la gestion des risques. Contrairement à la cascade, la spirale encourage des cycles répétitifs de prototypage et d&rsquo;évaluation. C&rsquo;est le premier pas majeur vers une reconnaissance que le logiciel doit évoluer par essais et erreurs plutôt que par un plan parfait initial.</p></li><li><p><strong>1991 : Linux et le Web (Technologie/Tendance)</strong>
Linus Torvalds publie le noyau Linux, prouvant que le modèle de développement &ldquo;Open Source&rdquo; pouvait produire des logiciels de qualité industrielle. Simultanément, Tim Berners-Lee invente le World Wide Web, transformant le logiciel en un outil de réseau mondial plutôt qu&rsquo;une application isolée.</p></li></ul><hr><h2 id=4-la-révolution-agile-et-internet-1995--2009>4. La révolution agile et Internet (1995 – 2009)<a class=anchor href=#4-la-r%c3%a9volution-agile-et-internet-1995--2009>#</a></h2><p><em>Focus : Vitesse, flexibilité et passage au navigateur comme plateforme principale.</em></p><ul><li><strong>1995 : Java et JavaScript (Langages)</strong>
Java a introduit la promesse &ldquo;Écrire une fois, exécuter partout&rdquo; grâce à sa machine virtuelle, tandis que JavaScript a permis de rendre le Web interactif. Ensemble, ils ont déplacé le centre de gravité du logiciel des machines locales vers les navigateurs et les serveurs distants.</li><li><strong>2001 : Le manifeste agile (Méthode)</strong>
Dix-sept experts se réunissent pour signer un texte qui privilégie &ldquo;les individus et leurs interactions&rdquo; sur les processus et les outils. C&rsquo;est un rejet massif des méthodes lourdes au profit de cycles de livraison courts et d&rsquo;une adaptation constante aux besoins changeants des clients.</li><li><strong>2006 : AWS et le cloud computing (Technologie)</strong>
Le lancement d&rsquo;Amazon Web Services a transformé l&rsquo;infrastructure en logiciel (Infrastructure-as-Code). Les développeurs n&rsquo;ont plus besoin d&rsquo;attendre des mois pour des serveurs physiques ; ils peuvent louer de la puissance de calcul à la demande, favorisant l&rsquo;émergence des architectures en microservices.</li><li><strong>2009 : Node.js (Technologie)</strong>
En permettant à JavaScript de s&rsquo;exécuter côté serveur, Node.js a unifié le développement web. Les développeurs peuvent désormais utiliser un seul langage pour l&rsquo;ensemble de la pile applicative (Full-stack), simplifiant radicalement les équipes et les processus de développement.</li></ul><hr><h2 id=5-lingénierie-continue-et-lia-2010--présent>5. L&rsquo;ingénierie continue et l&rsquo;IA (2010 – présent)<a class=anchor href=#5-ling%c3%a9nierie-continue-et-lia-2010--pr%c3%a9sent>#</a></h2><p><em>Focus : Automatisation totale, résilience et assistance par l&rsquo;intelligence artificielle.</em></p><ul><li><p><strong>2010 : L&rsquo;essor du DevOps (Tendance)</strong>
Le DevOps brise le mur entre le développement (Dev) et l&rsquo;exploitation (Ops). L&rsquo;objectif est l&rsquo;intégration et le déploiement continus (<strong>CI/CD</strong>), permettant à des entreprises de mettre à jour leur logiciel des dizaines de fois par jour sans interruption de service.</p></li><li><p><strong>2013 : Docker et les conteneurs (Technologie)</strong>
Docker a popularisé la conteneurisation, permettant d&rsquo;empaqueter une application avec toutes ses dépendances dans une unité isolée. Cela a résolu définitivement le problème du &ldquo;ça marche sur ma machine&rdquo;, garantissant qu&rsquo;un logiciel fonctionne à l&rsquo;identique dans tous les environnements.</p></li><li><p><strong>2017 : Modèles transformers et IA (Tendance)</strong>
La publication du papier &ldquo;Attention Is All You Need&rdquo; a posé les bases des grands modèles de langage (LLM). Aujourd&rsquo;hui, l&rsquo;IA change le métier d&rsquo;ingénieur : elle ne se contente plus d&rsquo;être intégrée aux produits, elle aide à générer, corriger et documenter le code via des assistants comme Copilot.</p></li><li><p><strong>Présent : Low-code et no-code (Tendance)</strong>
Un mouvement visant à démocratiser la création logicielle. En utilisant des interfaces visuelles pour construire des applications, ces outils permettent aux experts métier de créer leurs propres solutions, réduisant ainsi la dépendance historique envers les seuls ingénieurs logiciels pour les besoins simples.</p></li></ul><hr><h3 id=tableau-récapitulatif>Tableau récapitulatif<a class=anchor href=#tableau-r%c3%a9capitulatif>#</a></h3><table><thead><tr><th style=text-align:left>Époque</th><th style=text-align:left>Langage phare</th><th style=text-align:left>Système/OS phare</th><th style=text-align:left>Méthode dominante</th></tr></thead><tbody><tr><td style=text-align:left><strong>Pionniers</strong></td><td style=text-align:left>FORTRAN</td><td style=text-align:left>IBM OS/360</td><td style=text-align:left>Artisanale</td></tr><tr><td style=text-align:left><strong>Crise/Structure</strong></td><td style=text-align:left>C</td><td style=text-align:left>UNIX</td><td style=text-align:left>Cascade (Waterfall)</td></tr><tr><td style=text-align:left><strong>Objet / PC</strong></td><td style=text-align:left>C++</td><td style=text-align:left>Windows</td><td style=text-align:left>Spirale / Itératif</td></tr><tr><td style=text-align:left><strong>Agile/Web</strong></td><td style=text-align:left>Java / JS</td><td style=text-align:left>Linux</td><td style=text-align:left>Agile / Scrum</td></tr><tr><td style=text-align:left><strong>DevOps/IA</strong></td><td style=text-align:left>Go / Rust</td><td style=text-align:left>Cloud (AWS/Azure)</td><td style=text-align:left>DevOps / CI-CD</td></tr></tbody></table></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=https://cjauvin.github.io/inf1410-teluq/docs/module1/historique/ class="flex align-center"><img src=https://cjauvin.github.io/inf1410-teluq/icons/backward.svg class=book-icon alt=Backward>
<span>Les idées historiques importantes</span>
</a></span><span><a href=https://cjauvin.github.io/inf1410-teluq/docs/module2/ class="flex align-center"><span>Module 2 - La programmation</span>
<img src=https://cjauvin.github.io/inf1410-teluq/icons/forward.svg class=book-icon alt=Forward></a></span></div><div class=book-comments></div><script>(function(){document.querySelectorAll("pre:has(code)").forEach(e=>{e.addEventListener("click",e.focus),e.addEventListener("copy",function(t){if(t.preventDefault(),navigator.clipboard){const t=window.getSelection().toString()||e.textContent;navigator.clipboard.writeText(t)}})})})()</script></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#1-lère-des-pionniers-années-1940--1967>1. L&rsquo;ère des pionniers (Années 1940 – 1967)</a></li><li><a href=#2-la-naissance-du-génie-logiciel-1968--1982>2. La naissance du génie logiciel (1968 – 1982)</a></li><li><a href=#3-maîtriser-la-complexité-et-le-pc-1983--1994>3. Maîtriser la complexité et le PC (1983 – 1994)</a></li><li><a href=#4-la-révolution-agile-et-internet-1995--2009>4. La révolution agile et Internet (1995 – 2009)</a></li><li><a href=#5-lingénierie-continue-et-lia-2010--présent>5. L&rsquo;ingénierie continue et l&rsquo;IA (2010 – présent)</a><ul><li><a href=#tableau-récapitulatif>Tableau récapitulatif</a></li></ul></li></ul></nav></div></aside></main></body></html>