<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Module 3 - Les outils et les environnements on INF1410 - Initiation au génie logiciel</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/</link><description>Recent content in Module 3 - Les outils et les environnements on INF1410 - Initiation au génie logiciel</description><generator>Hugo</generator><language>fr</language><atom:link href="https://cjauvin.github.io/inf1410-teluq/docs/module3/index.xml" rel="self" type="application/rss+xml"/><item><title>Le versioning avec git</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/versioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module3/versioning/</guid><description>&lt;h1 id="le-versioning"&gt;Le versioning&lt;a class="anchor" href="#le-versioning"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;h2 id="quel-est-le-problème-quon-cherche-à-résoudre"&gt;Quel est le problème qu&amp;rsquo;on cherche à résoudre?&lt;a class="anchor" href="#quel-est-le-probl%c3%a8me-quon-cherche-%c3%a0-r%c3%a9soudre"&gt;#&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Le logiciel (et le code source dont il est constitué) a une particularité
fondamentale : il change tout le temps. Même un programme simple est rapidement
modifié - pour corriger un bug, ajouter une fonctionnalité, améliorer la
performance ou simplement rendre le code plus lisible. Et très vite, une
question apparaît : comment savoir ce qui a changé, quand, et pourquoi ?&lt;/p&gt;</description></item><item><title>La conteneurisation avec docker</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/docker/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module3/docker/</guid><description>&lt;h1 id="la-conteneurisation-avec-docker"&gt;La conteneurisation avec docker&lt;a class="anchor" href="#la-conteneurisation-avec-docker"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Cette section propose un chemin rapide et efficace pour comprendre ce qu’est la
technologie Docker, ses concepts de base, et comment utiliser certains de ses
outils principaux. Le but est de favoriser la création d’un modèle mental
robuste, et non de décrire exhaustivement les plus fins détails. Pour ce faire,
nous allons tout d’abord répondre à quelques questions courantes, et explorer
ensuite une série d’exemples, de manière progressive et cohérente.&lt;/p&gt;</description></item><item><title>La gestion des dépendances</title><link>https://cjauvin.github.io/inf1410-teluq/docs/module3/gestion-des-deps/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://cjauvin.github.io/inf1410-teluq/docs/module3/gestion-des-deps/</guid><description>&lt;h1 id="la-gestion-des-dépendances"&gt;La gestion des dépendances&lt;a class="anchor" href="#la-gestion-des-d%c3%a9pendances"&gt;#&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;Dès qu&amp;rsquo;un programme devient un peu plus complexe, deux phénomènes interviennent
habituellement :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Le programme est décomposé en plusieurs modules&lt;/li&gt;
&lt;li&gt;Certaines fonctionnalités du programmes peuvent être accomplies par des
programmes (ou des librairies) externes&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Dans le cas (2), on nomme parfois les librairies externes des &amp;ldquo;dépendances&amp;rdquo;, ou des
&amp;ldquo;paquets&amp;rdquo; (packages en anglais, plus communément).&lt;/p&gt;
&lt;p&gt;Dans les débuts de l&amp;rsquo;ingénierie logicielle, ces dépendances étaient gérées à la
main, en copiant et échangeant des fichiers.&lt;/p&gt;</description></item></channel></rss>